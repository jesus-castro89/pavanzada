# Actividad 11: Comprobando las clases

Antes de continuar con el resto del proyecto, es necesario asegurarnos de la existencia de la siguiente estructura de
paquetes y clases:

```
 src
org
brick_breaker
cache
FontCache.java
FontLoader.java
SpriteCache.java
SpriteLoader.java
game
Level.java
sprites
bonus
Bonus.java
BonusType.java
bricks
Brick.java
BrickType.java
paddles
Paddle.java
PaddleType.java
Ball.java
Borders.java
Missile.java
MovingSprite.java
Resettable.java
Sprite.java
ui
buttons
ButtonState.java
ThreePartButtonUI.java
events
KeyboardAction.java
StartButtonAction.java
StopButtonAction.jav
labels
LifeLabelUI.java
ScoreLabelUI.java
TitleLabel.java
panels
MainPanel.java
windows
GameOverWindow
GameOverWindow.java
GameOverWindow.form
MainWindow
MainWindow.java
MainWindow.form
StartWindow
StartWindow.java
StartWindow.form
utils
collisions
CollisionListener.java
CollisionManager.java
EdgeType.java
FileManager.java
GameCycle.java
Randomized.java
Main.java
```

漏generated by [Project Tree Generator](https://woochanleee.github.io/project-tree-generator)

Con esta estructura y clases es que finalizaremos el proyecto. Es importante destacar que el c贸digo de las clases se ha
abordado en su mayor parte en las actividades anteriores, por lo que no es necesario volver a explicarlo. Sin embargo,
se pueden realizar algunas modificaciones para mejorar la legibilidad y el rendimiento del c贸digo. A continuaci贸n, se
presentan las modificaciones que se pueden realizar en cada una de las clases.

## 1. Clase `FontCache`

```java
package org.brick_breaker.cache;

import java.awt.*;
import java.util.HashMap;
import java.util.Map;

public class FontCache {
    public static final Map<String, Font> cache = new HashMap<>();
    private static final FontCache INSTANCE = new FontCache();

    private FontCache() {
    }

    public static FontCache getInstance() {
        return INSTANCE;
    }
    
    public static Font addFont(String fontName, String fontPath) {
        Font font;
        if (!cache.containsKey(fontName)) {
            font = FontLoader.loadFont(fontPath);
            cache.put(fontName, font);
        } else
            font = cache.get(fontName);
        return font;
    }

    public static Font getFont(String fontName, int style, int size) {
        return cache.getOrDefault(fontName, Font.getFont("Arial")).deriveFont(style, size);
    }
    
    public static Font getFont(String fontName) {
        return getFont(fontName, Font.PLAIN, 12);
    }
    
    public static Font getFont(String fontName, int size) {
        return getFont(fontName, Font.PLAIN, size);
    }
}
```

## 2. Clase `FontLoader`

```java
package org.brick_breaker.cache;

import javax.swing.*;
import java.awt.*;
import java.io.File;

public class FontLoader {
    
    public static Font loadFont(String path) {
        try {
            return Font.createFont(Font.TRUETYPE_FONT, new File(path)).deriveFont(12f);
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Error al cargar la fuente: " + path,
                    "Error", JOptionPane.ERROR_MESSAGE);
        }
        return Font.getFont("Arial").deriveFont(12f);
    }
}
```

## 3. Clase `SpriteCache`

```java
package org.brick_breaker.cache;

import javax.swing.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;

public class SpriteCache {
    
    private final HashMap<String, BufferedImage> cache = new HashMap<>();
    private final HashMap<String, ImageIcon> gifCache = new HashMap<>();
    private static final SpriteCache INSTANCE = new SpriteCache();

    private SpriteCache() {
    }

    public static SpriteCache getInstance() {
        return INSTANCE;
    }

    public void addImage(String name, BufferedImage image) {
        cache.putIfAbsent(name, image);
    }

    public void addImage(String name, ImageIcon image) {
        gifCache.putIfAbsent(name, image);
    }

    public BufferedImage getImage(String name) {
        return cache.getOrDefault(name, null);
    }

    public ImageIcon getImageIcon(String name) {
        return gifCache.getOrDefault(name, null);
    }
}
```

## 4. Clase `SpriteLoader`

```java
package org.brick_breaker.cache;

import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

public class SpriteLoader {
    private static final String SPRITES_PATH = "image/";

    public static BufferedImage loadImage(String fileName) {
        try {
            return ImageIO.read(new File(SPRITES_PATH + fileName));
        } catch (IOException e) {
            JOptionPane.showConfirmDialog(null,
                    "Error al cargar la imagen: " + fileName,
                    "Error", JOptionPane.DEFAULT_OPTION,
                    JOptionPane.ERROR_MESSAGE);
        }
        return null;
    }

    public static ImageIcon loadGif(String fileName) {
        try {
            return new ImageIcon(SPRITES_PATH + fileName);
        } catch (Exception e) {
            JOptionPane.showConfirmDialog(null,
                    "Error al cargar la imagen: " + fileName,
                    "Error", JOptionPane.DEFAULT_OPTION,
                    JOptionPane.ERROR_MESSAGE);
            return null;
        }
    }
}
```

## 5. Clase `Level`

```java
package org.brick_breaker.game;

import org.brick_breaker.sprites.bricks.Brick;
import org.brick_breaker.sprites.bricks.BrickType;
import org.brick_breaker.utils.Randomized;

import java.awt.*;
import java.io.Serializable;

public class Level implements Serializable {
    
    public static final int ROW_MARGIN = 18;
    public static final int COLUMN_MARGIN = 19;
    public static final int LEVEL_WIDTH = 10;
    public static final int LEVEL_HEIGHT = 10;
    public static int levelNumber = 1;
    private Brick[][] bricks;
    private final String backgroundName;
    private final String musicName;
    private final int currentLevel;

    public Level() {
        this.backgroundName = "bg_level_" + levelNumber;
        this.musicName = "m_level_" + levelNumber;
        bricks = new Brick[LEVEL_WIDTH][LEVEL_HEIGHT];
        currentLevel = levelNumber++;
        populateLevel();
    }
    
    private void populateLevel() {
        BrickType brickType;
        Point position;
        for (int row = 0; row < LEVEL_WIDTH; row++) {
            for (int column = 0; column < LEVEL_HEIGHT; column++) {
                // Se genera un n煤mero aleatorio para seleccionar un tipo de ladrillo.
                brickType = BrickType.values()[Randomized.randomInt(0, BrickType.values().length - 1)];
                // Se gener谩 la posici贸n del ladrillo.
                position = new Point(column * Brick.BRICK_WIDTH + ROW_MARGIN,
                        row * Brick.BRICK_HEIGHT + COLUMN_MARGIN);
                // Se crea el ladrillo seg煤n el tipo.
                switch (brickType) {
                    case RED -> bricks[row][column] = new Brick(position, "red_brick", BrickType.RED);
                    case BLUE -> bricks[row][column] = new Brick(position, "blue_brick", BrickType.BLUE);
                    case GREEN -> bricks[row][column] = new Brick(position, "green_brick", BrickType.GREEN);
                    case YELLOW -> bricks[row][column] = new Brick(position, "yellow_brick", BrickType.YELLOW);
                }
            }
        }
    }

    public Brick[][] getBricks() {
        return bricks;
    }

    public void setBricks(Brick[][] bricks) {
        this.bricks = bricks;
    }

    public String getBackgroundName() {
        return backgroundName;
    }

    public int getCurrentLevel() {
        return currentLevel;
    }
}
```