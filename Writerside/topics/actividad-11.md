# Actividad 11: Comprobando las clases

Antes de continuar con el resto del proyecto, es necesario asegurarnos de la existencia de la siguiente estructura de
paquetes y clases:

```
📦 src
└─ org
   └─ brick_breaker
      ├─ cache
      │  ├─ FontCache.java
      │  ├─ FontLoader.java
      │  ├─ SpriteCache.java
      │  └─ SpriteLoader.java
      ├─ game
      │  └─ Level.java
      ├─ sprites
      │  ├─ bonus
      │  │  ├─ Bonus.java
      │  │  └─ BonusType.java
      │  ├─ bricks
      │  │  ├─ Brick.java
      │  │  └─ BrickType.java
      │  ├─ paddles
      │  │  ├─ Paddle.java
      │  │  └─ PaddleType.java
      │  ├─ Ball.java
      │  ├─ Borders.java
      │  ├─ Missile.java
      │  ├─ MovingSprite.java
      │  ├─ Resettable.java
      │  └─ Sprite.java
      ├─ ui
      │  ├─ buttons
      │  │  ├─ ButtonState.java
      │  │  └─ ThreePartButtonUI.java
      │  ├─ events
      │  │  ├─ KeyboardAction.java
      │  │  ├─ StartButtonAction.java
      │  │  └─ StopButtonAction.jav
      │  ├─ labels
      │  │  ├─ LifeLabelUI.java
      │  │  ├─ ScoreLabelUI.java
      │  │  └─ TitleLabel.java
      │  ├─ panels
      │  │  └─ MainPanel.java
      │  └─ windows
      │     ├─ GameOverWindow
      │     │  ├─ GameOverWindow.java
      │     │  └─ GameOverWindow.form
      │     ├─ MainWindow
      │     │  ├─ MainWindow.java
      │     │  └─ MainWindow.form
      │     └─ StartWindow
      │        ├─ StartWindow.java
      │        └─ StartWindow.form
      ├─ utils
      │  ├─ collisions
      │  │  ├─ CollisionListener.java
      │  │  ├─ CollisionManager.java
      │  │  └─ EdgeType.java
      │  ├─ FileManager.java
      │  ├─ GameCycle.java
      │  └─ Randomized.java
      └─ Main.java
```

©generated by [Project Tree Generator](https://woochanleee.github.io/project-tree-generator)

Con esta estructura y clases es que finalizaremos el proyecto. Es importante destacar que el código de las clases se ha
abordado en su mayor parte en las actividades anteriores, por lo que no es necesario volver a explicarlo. Sin embargo,
se pueden realizar algunas modificaciones para mejorar la legibilidad y el rendimiento del código. A continuación, se
presentan las modificaciones que se pueden realizar en cada una de las clases.

## 1. Clase `FontCache`

```java
package org.brick_breaker.cache;

import java.awt.*;
import java.util.HashMap;
import java.util.Map;

public class FontCache {
    public static final Map<String, Font> cache = new HashMap<>();
    private static final FontCache INSTANCE = new FontCache();

    private FontCache() {
    }

    public static FontCache getInstance() {
        return INSTANCE;
    }
    
    public static Font addFont(String fontName, String fontPath) {
        Font font;
        if (!cache.containsKey(fontName)) {
            font = FontLoader.loadFont(fontPath);
            cache.put(fontName, font);
        } else
            font = cache.get(fontName);
        return font;
    }

    public static Font getFont(String fontName, int style, int size) {
        return cache.getOrDefault(fontName, Font.getFont("Arial")).deriveFont(style, size);
    }
    
    public static Font getFont(String fontName) {
        return getFont(fontName, Font.PLAIN, 12);
    }
    
    public static Font getFont(String fontName, int size) {
        return getFont(fontName, Font.PLAIN, size);
    }
}
```

## 2. Clase `FontLoader`

```java
package org.brick_breaker.cache;

import javax.swing.*;
import java.awt.*;
import java.io.File;

public class FontLoader {
    
    public static Font loadFont(String path) {
        try {
            return Font.createFont(Font.TRUETYPE_FONT, new File(path)).deriveFont(12f);
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Error al cargar la fuente: " + path,
                    "Error", JOptionPane.ERROR_MESSAGE);
        }
        return Font.getFont("Arial").deriveFont(12f);
    }
}
```

## 3. Clase `SpriteCache`

```java
package org.brick_breaker.cache;

import javax.swing.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;

public class SpriteCache {
    
    private final HashMap<String, BufferedImage> cache = new HashMap<>();
    private final HashMap<String, ImageIcon> gifCache = new HashMap<>();
    private static final SpriteCache INSTANCE = new SpriteCache();

    private SpriteCache() {
    }

    public static SpriteCache getInstance() {
        return INSTANCE;
    }

    public void addImage(String name, BufferedImage image) {
        cache.putIfAbsent(name, image);
    }

    public void addImage(String name, ImageIcon image) {
        gifCache.putIfAbsent(name, image);
    }

    public BufferedImage getImage(String name) {
        return cache.getOrDefault(name, null);
    }

    public ImageIcon getImageIcon(String name) {
        return gifCache.getOrDefault(name, null);
    }
}
```

## 4. Clase `SpriteLoader`

```java
package org.brick_breaker.cache;

import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

public class SpriteLoader {
    private static final String SPRITES_PATH = "image/";

    public static BufferedImage loadImage(String fileName) {
        try {
            return ImageIO.read(new File(SPRITES_PATH + fileName));
        } catch (IOException e) {
            JOptionPane.showConfirmDialog(null,
                    "Error al cargar la imagen: " + fileName,
                    "Error", JOptionPane.DEFAULT_OPTION,
                    JOptionPane.ERROR_MESSAGE);
        }
        return null;
    }

    public static ImageIcon loadGif(String fileName) {
        try {
            return new ImageIcon(SPRITES_PATH + fileName);
        } catch (Exception e) {
            JOptionPane.showConfirmDialog(null,
                    "Error al cargar la imagen: " + fileName,
                    "Error", JOptionPane.DEFAULT_OPTION,
                    JOptionPane.ERROR_MESSAGE);
            return null;
        }
    }
}
```

## 5. Clase `Level`

```java
package org.brick_breaker.game;

import org.brick_breaker.sprites.bricks.Brick;
import org.brick_breaker.sprites.bricks.BrickType;
import org.brick_breaker.utils.Randomized;

import java.awt.*;
import java.io.Serializable;

public class Level implements Serializable {
    
    public static final int ROW_MARGIN = 18;
    public static final int COLUMN_MARGIN = 19;
    public static final int LEVEL_WIDTH = 10;
    public static final int LEVEL_HEIGHT = 10;
    public static int levelNumber = 1;
    private Brick[][] bricks;
    private final String backgroundName;
    private final String musicName;
    private final int currentLevel;

    public Level() {
        this.backgroundName = "bg_level_" + levelNumber;
        this.musicName = "m_level_" + levelNumber;
        bricks = new Brick[LEVEL_WIDTH][LEVEL_HEIGHT];
        currentLevel = levelNumber++;
        populateLevel();
    }
    
    private void populateLevel() {
        BrickType brickType;
        Point position;
        for (int row = 0; row < LEVEL_WIDTH; row++) {
            for (int column = 0; column < LEVEL_HEIGHT; column++) {
                // Se genera un número aleatorio para seleccionar un tipo de ladrillo.
                brickType = BrickType.values()[Randomized.randomInt(0, BrickType.values().length - 1)];
                // Se generá la posición del ladrillo.
                position = new Point(column * Brick.BRICK_WIDTH + ROW_MARGIN,
                        row * Brick.BRICK_HEIGHT + COLUMN_MARGIN);
                // Se crea el ladrillo según el tipo.
                switch (brickType) {
                    case RED -> bricks[row][column] = new Brick(position, "red_brick", BrickType.RED);
                    case BLUE -> bricks[row][column] = new Brick(position, "blue_brick", BrickType.BLUE);
                    case GREEN -> bricks[row][column] = new Brick(position, "green_brick", BrickType.GREEN);
                    case YELLOW -> bricks[row][column] = new Brick(position, "yellow_brick", BrickType.YELLOW);
                }
            }
        }
    }

    public Brick[][] getBricks() {
        return bricks;
    }

    public void setBricks(Brick[][] bricks) {
        this.bricks = bricks;
    }

    public String getBackgroundName() {
        return backgroundName;
    }

    public int getCurrentLevel() {
        return currentLevel;
    }
}
```